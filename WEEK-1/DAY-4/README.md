# Week 1 - Day 4

# Introduction to Gate Level Simulation

**What is gate level simualtion:**

Gate-Level Simulation (GLS) is the process of verifying the behavior of a digital design after it has been synthesized into a netlist of logic gates.

At the RTL (Register Transfer Level), you write Verilog/VHDL code and simulate it functionally.

But synthesis tools (like Synopsys DC, Cadence Genus, Yosys, etc.) transform that RTL into a gate-level netlist, which consists of standard cells (AND, OR, NAND, flip-flops, multiplexers, etc.) from a technology library.

**Why do we need GLS?**

When we design digital circuits, the RTL simulation (behavioral/functional simulation) is our first checkpoint. It ensures that the high-level Verilog or VHDL code behaves as intended. However, synthesis tools transform this RTL into a gate-level netlist that uses logic gates and flip-flops from a technology library.
This transformation may introduce subtle changes, and RTL simulation alone cannot guarantee that the synthesized hardware will behave correctly in silicon. That’s where Gate-Level Simulation (GLS) comes in.

***1. Validation of RTL vs Synthesized Netlist***

RTL code is written in a high-level, abstract way. The synthesis tool translates it into a gate-level representation.

Certain RTL constructs (like inferred latches, case statements without default, blocking vs non-blocking assignments, etc.) may lead to unexpected hardware structures.

GLS ensures that the gate-level netlist behaves the same way as the RTL simulation under real testbench scenarios.

***2. Reset and Initialization Verification***

In RTL simulation, uninitialized signals may default to 0 or X, depending on the simulator. Designers often assume registers start in a known state.

In real silicon, flip-flops power up in unknown states until explicitly reset.

GLS models this correctly: all flip-flops start as X (unknown) unless a reset signal is applied.

***3. Timing-Aware Verification***

RTL simulation assumes zero delay for all operations. This hides many timing-related problems.

At the gate level, each logic gate has a propagation delay, and interconnects add more delay.

GLS can be run with SDF (Standard Delay Format) annotation, which introduces actual cell and wire delays.

**Gate Level Simulation using iverilog:**

<img width="1818" height="833" alt="Screenshot 2025-09-26 092518" src="https://github.com/user-attachments/assets/487ba945-6c47-4936-bb86-c7b4d401fe98" />

When we move from RTL design to actual hardware implementation, the abstract description written in Verilog or VHDL is synthesized into a gate-level netlist. This netlist contains interconnected logic gates and flip-flops taken from a standard cell library. At the RTL level, simulation is purely functional: all assignments and logic are assumed to be ideal, without any propagation delay or timing uncertainty. However, in real silicon every gate has a finite delay, signals may glitch for short durations, and flip-flops can only capture data reliably if setup and hold conditions are met. To bridge this gap between idealized RTL simulation and real hardware behavior, gate-level simulation is performed.

Using Icarus Verilog, this flow begins with two fundamental components: the design itself and a testbench that provides stimulus. The design can first be written in RTL form, for example as a small circuit with combinational logic feeding into flip-flops. The testbench applies different input waveforms, toggles reset and clock signals, and observes outputs. At this stage the same RTL and testbench can be simulated directly with iverilog to confirm functional correctness. However, for gate-level simulation we do not use the RTL code directly. Instead, we use a gate-level Verilog netlist, which is either generated by a synthesis tool such as Yosys or written manually using primitive gates and explicit timing delays. This netlist no longer describes high-level behavior but rather instantiates specific gates like AND, OR, and D flip-flops, each potentially annotated with delays to mimic real hardware timing.

When the gate-level netlist and the testbench are compiled together using iverilog, the simulator produces an executable model. Running this simulation with vvp executes the design event by event in simulated time. Unlike RTL, the events are not instantaneous: if an input changes at a certain time, the output of a gate will only change after the propagation delay specified in the gate-level description. This allows hazards and glitches to appear in intermediate signals if inputs change at different times. Flip-flops in the gate netlist are also modeled more realistically, often showing unknown (X) states until reset is applied. This is closer to actual silicon, where registers at power-up are not guaranteed to be zero unless explicitly reset.

During simulation, the testbench invokes system tasks like $dumpfile and $dumpvars to record all signal activity into a Value Change Dump (VCD) file. This file contains a time-stamped log of how every signal changes during the run. The VCD itself is just text, but it encodes the full behavior of the circuit at the gate level, including unknown states, hazards, and delayed transitions. Once the simulation completes, the VCD is opened in GTKWave, which provides a graphical view of the waveforms. In GTKWave, signals from the testbench and the gate-level design are inspected. This is where the key differences between RTL and gate-level simulation become visible. One can see that outputs settle later than inputs due to gate delays, that intermediate signals may briefly glitch before stabilizing, and that flip-flop outputs do not initialize deterministically but depend on reset being asserted.

Using iverilog, the gate-level design is exercised in the same environment as the RTL but reveals timing effects, initialization problems, and glitch propagation that RTL alone could not uncover. By capturing these behaviors in a VCD file and analyzing them with GTKWave, designers gain visual and temporal confirmation that the synthesized design not only matches the RTL logically but also behaves robustly under realistic timing conditions.

## Simulation and Synthesis mismatch

When we design digital circuits in hardware description languages like Verilog or VHDL, the first step is to describe the behavior of the system at the register transfer level (RTL). This RTL code is then functionally simulated to check if the design behaves as expected. Once the design is verified at this level, it is passed to a synthesis tool, which translates the high-level RTL code into a gate-level netlist made up of logic cells and flip-flops from a standard library. Ideally, the synthesized netlist should be functionally equivalent to the RTL, so that whatever was tested during simulation is exactly what will be implemented in hardware. However, in practice, there are cases where the behavior seen in simulation does not match what synthesis produces. This discrepancy is known as a simulation–synthesis mismatch.

**Some cources of mismatch are :**

***1. Missing sensitivity list**
***2. Blocking and non-blocking assignments***
***3. Non-standard verilog coding***

**1. Missing sensitivity list**

In Verilog, when we describe combinational logic using always blocks, the sensitivity list defines the set of signals whose changes should trigger the block to re-execute. If this sensitivity list is incomplete or missing signals, then the simulation and the actual synthesized hardware can behave differently. 

This happens because simulation relies directly on the sensitivity list, whereas synthesis tools ignore it for combinational logic and instead analyze the logic equations to generate hardware.

**Example:**

```bash

always @(sel)
begin 
   if (sel)
      y = i1;
   else
      y = i0;
end
```

This code contains **always @(sel)** : This means the simulator will only re-execute the always block when sel changes.

Suppose sel = 1. Then y takes the value of i1.

Now if i1 changes while sel stays at 1, the block will not re-trigger, because the sensitivity list does not include i1. As a result, y will remain stuck at the old value, even though logically it should follow i1.

Similarly, if sel = 0 and i0 changes, the simulator will not update y either.

```bash

This will be the correct code

always @(*)
begin 
   if (sel)
      y = i1;
   else
      y = i0;
end
```
Here,**@(*)** automatically includes all signals used inside the block. This ensures the simulator and the synthesizer behave consistently.

**2. Blocking and non-blocking assignments**

***Blocking Assignments (=)***

Blocking assignments execute immediately in the given order, like statements in a software program. When the simulator encounters a blocking assignment, it updates the value of the variable instantly before moving to the next statement.

```bash
always @(posedge clk) begin
   a = b;
   c = a;
end
```
On a rising clock edge, the first line executes: a is assigned the current value of b.

Then the second line executes: c is assigned the updated value of a (which just became b).

So, after one clock edge, c will equal b.

In effect, both a and c take the value of b at the same clock cycle.

***Non-blocking Assignments (<=)***

Non-blocking assignments do not update immediately. Instead, the right-hand side (RHS) is evaluated at the triggering event, and the update to the left-hand side (LHS) happens at the end of the simulation time step (delta cycle). This allows all non-blocking assignments in a block to happen “in parallel.”

```bash
always @(posedge clk) begin
   a <= b;
   c <= a;
end
```
On a rising clock edge, a <= b; schedules a to be updated with b later.

At the same time, c <= a; schedules c to be updated with the old value of a (before the clock).

At the end of the clock cycle, both updates happen.

So after one clock edge: a gets the new value of b, c gets the previous value of a.

**Caveats with blocking statements:**

***1. Incorrect Modeling of combinational Logic***

```bash
always @(*)
begin
    y = q0 & c;
    q0 = a | c;
end
```

***Sequential Execution of Blocking Assignments***

In blocking assignments, statements execute one after another in order:

First, y = q0 & c; is executed. At this moment, q0 still has its old value from the previous evaluation.

Next, q0 = a | c; executes, updating q0 to the new value a | c.

***Effect on Simulation***

Because of the sequential nature of blocking assignments:

y does not see the new value of q0 in the same evaluation cycle.

It always computes y using the previous value of q0.

So the simulation result for y can lag behind what might be expected if someone thought q0 updates first.

```bash

# This is correct code
always @(*)
begin
    q0 = a | c;
    y = q0 & c;
end
```
In this code, blocking assignments do not introduce a mismatch because q0 is updated before it is used in y. Simulation and synthesis will behave the same. The key takeaway is that statement order in blocking assignments matters, and incorrect ordering can cause mismatches, especially in combinational blocks with multiple interdependent signals.

***Sequential Execution of Blocking Assignments***

The first line executes: q0 = a | c;.
At this point, q0 is updated immediately to the value of a | c.

The second line executes: y = q0 & c;.
Now, y uses the new value of q0, which was just updated in the previous line.

***Simulation Behavior***

In simulation, y is computed using the updated q0, so it effectively behaves like:

y=(a∣c)&c

This is a correct combinational expression, and the sequential execution of blocking assignments here does not cause mismatch because q0 is intended as a combinational signal updated within the same always block.

## SKY130RTL D4SK2 L1 Lab GLS Synth Sim Mismatch:

**1. ternary_operator_mux.v**

```bash
#Open the code
gvim ternary_operator_mux.v
```
<img width="1285" height="804" alt="Screenshot 2025-09-26 113907" src="https://github.com/user-attachments/assets/ce0166d2-5d51-4574-8b4f-8cf15c4d5652" />


```bash
#Compile Verilog files using Icarus Verilog
iverilog ternary_operator_mux.v tb_ternary_operator_mux.v

#Run the compiled simulation
./a.out

#View waveform results in GTKWave
gtkwave dumpfile.vcd

```
<img width="1288" height="805" alt="Screenshot 2025-09-26 114043" src="https://github.com/user-attachments/assets/0d8056ff-718a-4a15-9901-3858c581774a" />


**For synthesis**

```bash

#open the yosys
yosys

#Read the liberty file
read_liberty -lib ../my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.lib

#Read the verilog file
read_verilog  ternary_operator_mux.v

#for synthesis
synth -top  ternary_operator_mux
```
<img width="1122" height="315" alt="Screenshot 2025-09-26 114144" src="https://github.com/user-attachments/assets/c5749c17-e747-4dbd-81ab-c02bcf35aea1" />


```bash

#run the ABC tool
abc -liberty ../my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.lib

#export a clean gate-level Verilog netlist
write_verilog -noattr ternary_operator_mux_net.v

#see the hierarchy
show 
```
<img width="1257" height="810" alt="Screenshot 2025-09-26 120045" src="https://github.com/user-attachments/assets/6f68c12e-ed32-4b9f-905c-f14ce4ae1ff8" />


**simulation after Gate Level Synthesis**
```bash

#compiles the standard-cell library, gate-level netlist, and testbench into a simulation executable
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130-fd-sc-hd.v ternary_operator_mux_net.v tb_ternary_operator_mux_net.v

#Run the compile simulation
./a.out

#View waveform results in GTKWave
gtkwave dumpfile.vcd
```

<img width="1268" height="808" alt="Screenshot 2025-09-26 120343" src="https://github.com/user-attachments/assets/b69e94e3-6d8f-4dcc-9b1b-2e21850d30f1" />

**1. bad_mux.v**

```bash
#Open the code
gvim bad_mux.v
```
<img width="1280" height="809" alt="Screenshot 2025-09-26 121015" src="https://github.com/user-attachments/assets/75c17dd0-17c7-4d70-a783-2ba1d41f5344" />


```bash
#Compile Verilog files using Icarus Verilog
iverilog bad_mux.v tb_bad_mux.v

#Run the compiled simulation
./a.out

#View waveform results in GTKWave
gtkwave dumpfile.vcd

```
<img width="1288" height="807" alt="Screenshot 2025-09-26 121130" src="https://github.com/user-attachments/assets/123bdaa3-1d45-4397-8e57-5901461fe190" />


**For synthesis**

```bash

#open the yosys
yosys

#Read the liberty file
read_liberty -lib ../my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.lib

#Read the verilog file
read_verilog  bad_mux.v

#for synthesis
synth -top  bad_mux
```
<img width="1129" height="267" alt="Screenshot 2025-09-26 121318" src="https://github.com/user-attachments/assets/cc90497b-25e0-446c-94cd-39a32109e94d" />


```bash

#run the ABC tool
abc -liberty ../my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.lib

#export a clean gate-level Verilog netlist
write_verilog -noattr bad_mux_net.v

#see the hierarchy
show 
```
<img width="1287" height="807" alt="Screenshot 2025-09-26 121513" src="https://github.com/user-attachments/assets/f42d6599-0caa-4335-bb0d-ad679c818e9a" />


**simulation after Gate Level Synthesis**
```bash

#compiles the standard-cell library, gate-level netlist, and testbench into a simulation executable
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130-fd-sc-hd.v bad_mux_net.v tb_bad_mux_net.v

#Run the compile simulation
./a.out

#View waveform results in GTKWave
gtkwave dumpfile.vcd
```

<img width="1289" height="811" alt="Screenshot 2025-09-26 121714" src="https://github.com/user-attachments/assets/80f854d4-907b-48c3-a8d5-f27601f44812" />

## SKY130RTL D4SK3 L1 Lab Synth sim mismatch blocking statement 
**blocking_caveat**

```bash
#Open the code
gvim blocking_caveat.v
```
<img width="1284" height="808" alt="Screenshot 2025-09-26 122212" src="https://github.com/user-attachments/assets/83dd6515-bff6-42fe-9f2a-41a06a977896" />


```bash
#Compile Verilog files using Icarus Verilog
iverilog blocking_caveat.v tb_blocking_caveat.v

#Run the compiled simulation
./a.out

#View waveform results in GTKWave
gtkwave dumpfile.vcd

```
<img width="1297" height="809" alt="Screenshot 2025-09-26 122418" src="https://github.com/user-attachments/assets/62ebe5cf-8175-48e0-8468-addab6eb5533" />


**For synthesis**

```bash

#open the yosys
yosys

#Read the liberty file
read_liberty -lib ../my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.lib

#Read the verilog file
read_verilog blocking_caveat.v

#for synthesis
synth -top  blocking_caveat
```
<img width="1140" height="321" alt="Screenshot 2025-09-26 122602" src="https://github.com/user-attachments/assets/9c387d4c-0f98-46d1-bc19-1ffdf8f32b10" />


```bash

#run the ABC tool
abc -liberty ../my_lib/lib/sky130_fd_sc_hd_tt_025C_1v80.lib

#export a clean gate-level Verilog netlist
write_verilog -noattr blocking_caveat_net.v

#see the hierarchy
show 
```
<img width="1286" height="809" alt="Screenshot 2025-09-26 123130" src="https://github.com/user-attachments/assets/996e7330-ffff-4990-b4dd-a1c9e7de5cb7" />


**simulation after Gate Level Synthesis**
```bash

#compiles the standard-cell library, gate-level netlist, and testbench into a simulation executable
iverilog ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130-fd-sc-hd.v blocking_caveat_net.v tb_blocking_caveat_net.v

#Run the compile simulation
./a.out

#View waveform results in GTKWave
gtkwave dumpfile.vcd
```

<img width="1292" height="809" alt="Screenshot 2025-09-26 123331" src="https://github.com/user-attachments/assets/054514f8-7bf0-439c-9cf7-084a21a1da06" />





















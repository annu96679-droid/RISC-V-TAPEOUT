# Week 1 - Day 4

# Introduction to Gate Level Simulation

**What is gate level simualtion:**

Gate-Level Simulation (GLS) is the process of verifying the behavior of a digital design after it has been synthesized into a netlist of logic gates.

At the RTL (Register Transfer Level), you write Verilog/VHDL code and simulate it functionally.

But synthesis tools (like Synopsys DC, Cadence Genus, Yosys, etc.) transform that RTL into a gate-level netlist, which consists of standard cells (AND, OR, NAND, flip-flops, multiplexers, etc.) from a technology library.

**Why do we need GLS?**

When we design digital circuits, the RTL simulation (behavioral/functional simulation) is our first checkpoint. It ensures that the high-level Verilog or VHDL code behaves as intended. However, synthesis tools transform this RTL into a gate-level netlist that uses logic gates and flip-flops from a technology library.
This transformation may introduce subtle changes, and RTL simulation alone cannot guarantee that the synthesized hardware will behave correctly in silicon. That’s where Gate-Level Simulation (GLS) comes in.

***1. Validation of RTL vs Synthesized Netlist***

RTL code is written in a high-level, abstract way. The synthesis tool translates it into a gate-level representation.

Certain RTL constructs (like inferred latches, case statements without default, blocking vs non-blocking assignments, etc.) may lead to unexpected hardware structures.

GLS ensures that the gate-level netlist behaves the same way as the RTL simulation under real testbench scenarios.

***2. Reset and Initialization Verification***

In RTL simulation, uninitialized signals may default to 0 or X, depending on the simulator. Designers often assume registers start in a known state.

In real silicon, flip-flops power up in unknown states until explicitly reset.

GLS models this correctly: all flip-flops start as X (unknown) unless a reset signal is applied.

***3. Timing-Aware Verification***

RTL simulation assumes zero delay for all operations. This hides many timing-related problems.

At the gate level, each logic gate has a propagation delay, and interconnects add more delay.

GLS can be run with SDF (Standard Delay Format) annotation, which introduces actual cell and wire delays.

**Gate Level Simulation using iverilog:**

<img width="1818" height="833" alt="Screenshot 2025-09-26 092518" src="https://github.com/user-attachments/assets/487ba945-6c47-4936-bb86-c7b4d401fe98" />

When we move from RTL design to actual hardware implementation, the abstract description written in Verilog or VHDL is synthesized into a gate-level netlist. This netlist contains interconnected logic gates and flip-flops taken from a standard cell library. At the RTL level, simulation is purely functional: all assignments and logic are assumed to be ideal, without any propagation delay or timing uncertainty. However, in real silicon every gate has a finite delay, signals may glitch for short durations, and flip-flops can only capture data reliably if setup and hold conditions are met. To bridge this gap between idealized RTL simulation and real hardware behavior, gate-level simulation is performed.

Using Icarus Verilog, this flow begins with two fundamental components: the design itself and a testbench that provides stimulus. The design can first be written in RTL form, for example as a small circuit with combinational logic feeding into flip-flops. The testbench applies different input waveforms, toggles reset and clock signals, and observes outputs. At this stage the same RTL and testbench can be simulated directly with iverilog to confirm functional correctness. However, for gate-level simulation we do not use the RTL code directly. Instead, we use a gate-level Verilog netlist, which is either generated by a synthesis tool such as Yosys or written manually using primitive gates and explicit timing delays. This netlist no longer describes high-level behavior but rather instantiates specific gates like AND, OR, and D flip-flops, each potentially annotated with delays to mimic real hardware timing.

When the gate-level netlist and the testbench are compiled together using iverilog, the simulator produces an executable model. Running this simulation with vvp executes the design event by event in simulated time. Unlike RTL, the events are not instantaneous: if an input changes at a certain time, the output of a gate will only change after the propagation delay specified in the gate-level description. This allows hazards and glitches to appear in intermediate signals if inputs change at different times. Flip-flops in the gate netlist are also modeled more realistically, often showing unknown (X) states until reset is applied. This is closer to actual silicon, where registers at power-up are not guaranteed to be zero unless explicitly reset.

During simulation, the testbench invokes system tasks like $dumpfile and $dumpvars to record all signal activity into a Value Change Dump (VCD) file. This file contains a time-stamped log of how every signal changes during the run. The VCD itself is just text, but it encodes the full behavior of the circuit at the gate level, including unknown states, hazards, and delayed transitions. Once the simulation completes, the VCD is opened in GTKWave, which provides a graphical view of the waveforms. In GTKWave, signals from the testbench and the gate-level design are inspected. This is where the key differences between RTL and gate-level simulation become visible. One can see that outputs settle later than inputs due to gate delays, that intermediate signals may briefly glitch before stabilizing, and that flip-flop outputs do not initialize deterministically but depend on reset being asserted.

Using iverilog, the gate-level design is exercised in the same environment as the RTL but reveals timing effects, initialization problems, and glitch propagation that RTL alone could not uncover. By capturing these behaviors in a VCD file and analyzing them with GTKWave, designers gain visual and temporal confirmation that the synthesized design not only matches the RTL logically but also behaves robustly under realistic timing conditions.

## Simulation and Synthesis mismatch

When we design digital circuits in hardware description languages like Verilog or VHDL, the first step is to describe the behavior of the system at the register transfer level (RTL). This RTL code is then functionally simulated to check if the design behaves as expected. Once the design is verified at this level, it is passed to a synthesis tool, which translates the high-level RTL code into a gate-level netlist made up of logic cells and flip-flops from a standard library. Ideally, the synthesized netlist should be functionally equivalent to the RTL, so that whatever was tested during simulation is exactly what will be implemented in hardware. However, in practice, there are cases where the behavior seen in simulation does not match what synthesis produces. This discrepancy is known as a simulation–synthesis mismatch.

**Some cources of mismatch are :**

***1. Missing sensitivity list**
***2. Blocking and non-blocking assignments***
***3. Non-standard verilog coding***

**1. Missing sensitivity list**

In Verilog, when we describe combinational logic using always blocks, the sensitivity list defines the set of signals whose changes should trigger the block to re-execute. If this sensitivity list is incomplete or missing signals, then the simulation and the actual synthesized hardware can behave differently. 

This happens because simulation relies directly on the sensitivity list, whereas synthesis tools ignore it for combinational logic and instead analyze the logic equations to generate hardware.

**Example:**

```bash

always @(sel)
begin 
   if (sel)
      y = i1;
   else
      y = i0;
end
```

This code contains **always @(sel)** : This means the simulator will only re-execute the always block when sel changes.

Suppose sel = 1. Then y takes the value of i1.

Now if i1 changes while sel stays at 1, the block will not re-trigger, because the sensitivity list does not include i1. As a result, y will remain stuck at the old value, even though logically it should follow i1.

Similarly, if sel = 0 and i0 changes, the simulator will not update y either.

```bash

This will be the correct code

always @(*)
begin 
   if (sel)
      y = i1;
   else
      y = i0;
end
```
Here,**@(*)** automatically includes all signals used inside the block. This ensures the simulator and the synthesizer behave consistently.

**2. Blocking and non-blocking assignments**

***Blocking Assignments (=)***

Blocking assignments execute immediately in the given order, like statements in a software program. When the simulator encounters a blocking assignment, it updates the value of the variable instantly before moving to the next statement.

```bash
always @(posedge clk) begin
   a = b;
   c = a;
end
```
On a rising clock edge, the first line executes: a is assigned the current value of b.

Then the second line executes: c is assigned the updated value of a (which just became b).

So, after one clock edge, c will equal b.

In effect, both a and c take the value of b at the same clock cycle.

***Non-blocking Assignments (<=)***

Non-blocking assignments do not update immediately. Instead, the right-hand side (RHS) is evaluated at the triggering event, and the update to the left-hand side (LHS) happens at the end of the simulation time step (delta cycle). This allows all non-blocking assignments in a block to happen “in parallel.”

```bash
always @(posedge clk) begin
   a <= b;
   c <= a;
end
```
On a rising clock edge, a <= b; schedules a to be updated with b later.

At the same time, c <= a; schedules c to be updated with the old value of a (before the clock).

At the end of the clock cycle, both updates happen.

So after one clock edge: a gets the new value of b, c gets the previous value of a.











# Week 1 - Day 4

# Introduction to Gate Level Simulation

**What is gate level simualtion:**

Gate-Level Simulation (GLS) is the process of verifying the behavior of a digital design after it has been synthesized into a netlist of logic gates.

At the RTL (Register Transfer Level), you write Verilog/VHDL code and simulate it functionally.

But synthesis tools (like Synopsys DC, Cadence Genus, Yosys, etc.) transform that RTL into a gate-level netlist, which consists of standard cells (AND, OR, NAND, flip-flops, multiplexers, etc.) from a technology library.

**Why do we need GLS?**

When we design digital circuits, the RTL simulation (behavioral/functional simulation) is our first checkpoint. It ensures that the high-level Verilog or VHDL code behaves as intended. However, synthesis tools transform this RTL into a gate-level netlist that uses logic gates and flip-flops from a technology library.
This transformation may introduce subtle changes, and RTL simulation alone cannot guarantee that the synthesized hardware will behave correctly in silicon. That’s where Gate-Level Simulation (GLS) comes in.

***1. Validation of RTL vs Synthesized Netlist***

RTL code is written in a high-level, abstract way. The synthesis tool translates it into a gate-level representation.

Certain RTL constructs (like inferred latches, case statements without default, blocking vs non-blocking assignments, etc.) may lead to unexpected hardware structures.

GLS ensures that the gate-level netlist behaves the same way as the RTL simulation under real testbench scenarios.

***2. Reset and Initialization Verification***

In RTL simulation, uninitialized signals may default to 0 or X, depending on the simulator. Designers often assume registers start in a known state.

In real silicon, flip-flops power up in unknown states until explicitly reset.

GLS models this correctly: all flip-flops start as X (unknown) unless a reset signal is applied.

***3. Timing-Aware Verification***

RTL simulation assumes zero delay for all operations. This hides many timing-related problems.

At the gate level, each logic gate has a propagation delay, and interconnects add more delay.

GLS can be run with SDF (Standard Delay Format) annotation, which introduces actual cell and wire delays.

**Gate Level Simulation using iverilog:**

<img width="1818" height="833" alt="Screenshot 2025-09-26 092518" src="https://github.com/user-attachments/assets/487ba945-6c47-4936-bb86-c7b4d401fe98" />

When we move from RTL design to actual hardware implementation, the abstract description written in Verilog or VHDL is synthesized into a gate-level netlist. This netlist contains interconnected logic gates and flip-flops taken from a standard cell library. At the RTL level, simulation is purely functional: all assignments and logic are assumed to be ideal, without any propagation delay or timing uncertainty. However, in real silicon every gate has a finite delay, signals may glitch for short durations, and flip-flops can only capture data reliably if setup and hold conditions are met. To bridge this gap between idealized RTL simulation and real hardware behavior, gate-level simulation is performed.

Using Icarus Verilog, this flow begins with two fundamental components: the design itself and a testbench that provides stimulus. The design can first be written in RTL form, for example as a small circuit with combinational logic feeding into flip-flops. The testbench applies different input waveforms, toggles reset and clock signals, and observes outputs. At this stage the same RTL and testbench can be simulated directly with iverilog to confirm functional correctness. However, for gate-level simulation we do not use the RTL code directly. Instead, we use a gate-level Verilog netlist, which is either generated by a synthesis tool such as Yosys or written manually using primitive gates and explicit timing delays. This netlist no longer describes high-level behavior but rather instantiates specific gates like AND, OR, and D flip-flops, each potentially annotated with delays to mimic real hardware timing.

When the gate-level netlist and the testbench are compiled together using iverilog, the simulator produces an executable model. Running this simulation with vvp executes the design event by event in simulated time. Unlike RTL, the events are not instantaneous: if an input changes at a certain time, the output of a gate will only change after the propagation delay specified in the gate-level description. This allows hazards and glitches to appear in intermediate signals if inputs change at different times. Flip-flops in the gate netlist are also modeled more realistically, often showing unknown (X) states until reset is applied. This is closer to actual silicon, where registers at power-up are not guaranteed to be zero unless explicitly reset.

During simulation, the testbench invokes system tasks like $dumpfile and $dumpvars to record all signal activity into a Value Change Dump (VCD) file. This file contains a time-stamped log of how every signal changes during the run. The VCD itself is just text, but it encodes the full behavior of the circuit at the gate level, including unknown states, hazards, and delayed transitions. Once the simulation completes, the VCD is opened in GTKWave, which provides a graphical view of the waveforms. In GTKWave, signals from the testbench and the gate-level design are inspected. This is where the key differences between RTL and gate-level simulation become visible. One can see that outputs settle later than inputs due to gate delays, that intermediate signals may briefly glitch before stabilizing, and that flip-flop outputs do not initialize deterministically but depend on reset being asserted.

Using iverilog, the gate-level design is exercised in the same environment as the RTL but reveals timing effects, initialization problems, and glitch propagation that RTL alone could not uncover. By capturing these behaviors in a VCD file and analyzing them with GTKWave, designers gain visual and temporal confirmation that the synthesized design not only matches the RTL logically but also behaves robustly under realistic timing conditions.

## Simulation and Synthesis mismatch

When we design digital circuits in hardware description languages like Verilog or VHDL, the first step is to describe the behavior of the system at the register transfer level (RTL). This RTL code is then functionally simulated to check if the design behaves as expected. Once the design is verified at this level, it is passed to a synthesis tool, which translates the high-level RTL code into a gate-level netlist made up of logic cells and flip-flops from a standard library. Ideally, the synthesized netlist should be functionally equivalent to the RTL, so that whatever was tested during simulation is exactly what will be implemented in hardware. However, in practice, there are cases where the behavior seen in simulation does not match what synthesis produces. This discrepancy is known as a simulation–synthesis mismatch.

